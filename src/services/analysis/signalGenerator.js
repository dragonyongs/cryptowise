import { technicalAnalysis } from "./technicalAnalysis";

/**
 * CryptoWise Ïã†Ìò∏ ÏÉùÏÑ±Í∏∞
 * Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Í∏∞Î∞òÏúºÎ°ú Îß§Ïàò/Îß§ÎèÑ Ïã†Ìò∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§
 */

class SignalGenerator {
  constructor() {
    // CryptoWise Ï†ÑÎûµ Í∞ÄÏ§ëÏπò [11]
    this.weights = {
      technical: {
        rsi: 0.25, // RSI 25%
        movingAverage: 0.2, // Ïù¥ÎèôÌèâÍ∑† 20%
        bollinger: 0.15, // Î≥ºÎßÅÍ±∞Î∞¥Îìú 15%
        macd: 0.15, // MACD 15%
        volume: 0.1, // Í±∞ÎûòÎüâ 10%
        support: 0.15, // ÏßÄÏßÄÏ†ÄÌï≠ 15%
      },
    };

    // ‚úÖ Í∏∞Î≥∏ Ïã†Ìò∏ ÏûÑÍ≥ÑÍ∞í (ÏÑ§Ï†ïÏúºÎ°ú Ïò§Î≤ÑÎùºÏù¥Îìú Í∞ÄÎä•)
    this.defaultThresholds = {
      minBuyScore: 7.5, // Í∏∞Î≥∏ Îß§Ïàò Ï†êÏàò
      minSellScore: 6.0, // Îß§ÎèÑ Ï†êÏàò
      strongBuyScore: 9.0, // Í∞ïÎ†•Îß§Ïàò 9Ï†ê Ïù¥ÏÉÅ
      maxScore: 10.0, // ÏµúÎåÄ Ï†êÏàò
    };

    // ÏΩîÏù∏Î≥Ñ ÌäπÎ≥Ñ Ï°∞Í±¥ [11]
    this.coinSpecificRules = {
      BTC: {
        rsiOversold: 35,
        rsiOverbought: 75,
        volumeMultiplier: 1.2,
      },
      ETH: {
        rsiOversold: 30,
        rsiOverbought: 70,
        volumeMultiplier: 1.5,
      },
      XRP: {
        rsiOversold: 25,
        rsiOverbought: 75,
        volumeMultiplier: 2.0,
      },
    };
  }

  /**
   * ‚úÖ ÏÑ§Ï†ï Í∏∞Î∞ò Ïã†Ìò∏ ÏÉùÏÑ± Ìï®Ïàò (ÏÉàÎ°ú Ï∂îÍ∞Ä)
   */
  async generateSignalsWithSettings(marketDataArray, userSettings = {}) {
    console.log("üéØ ÏÑ§Ï†ï Í∏∞Î∞ò Ïã†Ìò∏ ÏÉùÏÑ±:", marketDataArray.length, "Í∞ú ÏΩîÏù∏");
    console.log("üìã ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï:", userSettings);

    const signals = [];
    const thresholds = { ...this.defaultThresholds, ...userSettings };

    for (const marketData of marketDataArray) {
      try {
        const signal = await this.analyzeSymbolWithSettings(
          marketData,
          thresholds
        );
        if (signal && signal.totalScore >= thresholds.minBuyScore) {
          signals.push(signal);
          console.log(
            `‚úÖ Ïã†Ìò∏ ÏÉùÏÑ±: ${signal.symbol} ${signal.type} (${signal.totalScore.toFixed(1)}Ï†ê) - ÏÑ§Ï†ï: ${userSettings.strategy || "default"}`
          );
        }
      } catch (error) {
        console.error(
          `‚ùå Ïã†Ìò∏ ÏÉùÏÑ± Ïò§Î•ò (${marketData.symbol}):`,
          error.message
        );
      }
    }

    // Ï†êÏàò ÎÜíÏùÄ ÏàúÏúºÎ°ú Ï†ïÎ†¨
    return signals.sort((a, b) => b.totalScore - a.totalScore);
  }

  /**
   * ‚úÖ ÏÑ§Ï†ï Í∏∞Î∞ò Í∞úÎ≥Ñ ÏΩîÏù∏ Î∂ÑÏÑù (ÏÉàÎ°ú Ï∂îÍ∞Ä)
   */
  async analyzeSymbolWithSettings(marketData, settings) {
    const { symbol, price, volume24h, rsi, macd, bollinger } = marketData;

    // 1. Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï†êÏàò Í≥ÑÏÇ∞
    const technicalScores = this.calculateTechnicalScores(marketData);

    // 2. Ï¥ùÏ†ê Í≥ÑÏÇ∞
    const totalScore = this.calculateTotalScore(technicalScores);

    // 3. ÏÑ§Ï†ï Í∏∞Î∞ò Ïã†Ìò∏ Ïú†Ìòï Í≤∞Ï†ï
    const signalType = this.determineSignalTypeWithSettings(
      marketData,
      totalScore,
      settings
    );

    if (!signalType) return null;

    // 4. Ïã†Ìò∏ Í∞ùÏ≤¥ ÏÉùÏÑ±
    return {
      symbol,
      type: signalType,
      price,
      totalScore,
      technicalScore: totalScore,
      fundamentalScore: 0,
      marketScore: 0,
      riskScore: this.calculateRiskScore(marketData),
      timestamp: new Date(),
      reason: this.generateReasonWithSettings(
        marketData,
        signalType,
        totalScore,
        settings
      ),
      confidence: this.calculateConfidence(totalScore),
      volume24h,
      indicators: {
        rsi: marketData.rsi,
        macd: marketData.macd,
        bollinger: marketData.bollinger,
      },
      settings: settings, // ‚úÖ ÏÇ¨Ïö©Îêú ÏÑ§Ï†ï Ìè¨Ìï®
    };
  }

  /**
   * ‚úÖ ÏÑ§Ï†ï Í∏∞Î∞ò Ïã†Ìò∏ Ïú†Ìòï Í≤∞Ï†ï (ÏÉàÎ°ú Ï∂îÍ∞Ä)
   */
  determineSignalTypeWithSettings(marketData, totalScore, settings) {
    const { rsi } = marketData;

    console.log(
      `üîç ${marketData.symbol} Ïã†Ìò∏ÌåêÎã®: Ï†êÏàò=${totalScore.toFixed(2)}, RSI=${rsi?.toFixed(1)}, ÏµúÏÜåÏ†êÏàò=${settings.minBuyScore}`
    );

    // Îß§Ïàò Ïã†Ìò∏ Ï°∞Í±¥ (ÏÑ§Ï†ï Í∏∞Î∞ò)
    if (totalScore >= settings.minBuyScore) {
      if (rsi && rsi < (settings.rsiOverbought || 75)) {
        console.log(`‚úÖ ${marketData.symbol} Îß§ÏàòÏã†Ìò∏ Î∞úÏÉù! (ÏÑ§Ï†ï Í∏∞Î∞ò)`);
        return "BUY";
      }
    }

    // Îß§ÎèÑ Ïã†Ìò∏ Ï°∞Í±¥ (ÏÑ§Ï†ï Í∏∞Î∞ò)
    if (
      totalScore <= (settings.minSellScore || 3) ||
      (rsi && rsi > (settings.rsiOverbought || 80))
    ) {
      return "SELL";
    }

    return null;
  }

  /**
   * ‚úÖ ÏÑ§Ï†ï Í∏∞Î∞ò ÏÇ¨Ïú† ÏÉùÏÑ± (ÏÉàÎ°ú Ï∂îÍ∞Ä)
   */
  generateReasonWithSettings(marketData, signalType, totalScore, settings) {
    const { symbol, rsi, volume24h, avgVolume } = marketData;
    const volumeRatio =
      volume24h && avgVolume ? (volume24h / avgVolume).toFixed(1) : "?";

    if (signalType === "BUY") {
      if (totalScore >= (settings.strongBuyScore || 9.0)) {
        return `${symbol} Í∞ïÎ†•Îß§Ïàò: Ï¢ÖÌï©Ï†êÏàò ${totalScore.toFixed(1)}Ï†ê, RSI ${rsi?.toFixed(1)}, Í±∞ÎûòÎüâ ${volumeRatio}Î∞∞ (${settings.strategy || "default"} Ï†ÑÎûµ)`;
      } else {
        return `${symbol} Îß§Ïàò: Ï¢ÖÌï©Ï†êÏàò ${totalScore.toFixed(1)}Ï†ê, RSI ${rsi?.toFixed(1)} (${settings.strategy || "default"} Ï†ÑÎûµ)`;
      }
    } else if (signalType === "SELL") {
      return `${symbol} Îß§ÎèÑ: Í∏∞Ïà†Ï†Å Í≥ºÏó¥, RSI ${rsi?.toFixed(1)} (${settings.strategy || "default"} Ï†ÑÎûµ)`;
    }

    return `${symbol} Î∂ÑÏÑùÏôÑÎ£å (${settings.strategy || "default"})`;
  }

  /**
   * Î©îÏù∏ Ïã†Ìò∏ ÏÉùÏÑ± Ìï®Ïàò (Í∏∞Ï°¥ Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
   */
  async generateSignals(marketDataArray, strategy = "cryptowise") {
    console.log("üéØ Ïã†Ìò∏ ÏÉùÏÑ± ÏãúÏûë:", marketDataArray.length, "Í∞ú ÏΩîÏù∏");
    const signals = [];

    for (const marketData of marketDataArray) {
      try {
        const signal = await this.analyzeSymbol(marketData, strategy);
        if (signal && signal.totalScore >= this.defaultThresholds.minBuyScore) {
          signals.push(signal);
          console.log(
            `‚úÖ Ïã†Ìò∏ ÏÉùÏÑ±: ${signal.symbol} ${signal.type} (${signal.totalScore.toFixed(1)}Ï†ê)`
          );
        }
      } catch (error) {
        console.error(
          `‚ùå Ïã†Ìò∏ ÏÉùÏÑ± Ïò§Î•ò (${marketData.symbol}):`,
          error.message
        );
      }
    }

    return signals.sort((a, b) => b.totalScore - a.totalScore);
  }

  /**
   * Í∞úÎ≥Ñ ÏΩîÏù∏ Î∂ÑÏÑù (Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ)
   */
  async analyzeSymbol(marketData, strategy) {
    const { symbol, price, volume24h, rsi, macd, bollinger } = marketData;

    // 1. Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï†êÏàò Í≥ÑÏÇ∞
    const technicalScores = this.calculateTechnicalScores(marketData);

    // 2. Ï¥ùÏ†ê Í≥ÑÏÇ∞
    const totalScore = this.calculateTotalScore(technicalScores);

    // 3. Ïã†Ìò∏ Ïú†Ìòï Í≤∞Ï†ï
    const signalType = this.determineSignalType(marketData, totalScore);

    if (!signalType) return null;

    // 4. Ïã†Ìò∏ Í∞ùÏ≤¥ ÏÉùÏÑ±
    return {
      symbol,
      type: signalType,
      price,
      totalScore,
      technicalScore: totalScore,
      fundamentalScore: 0,
      marketScore: 0,
      riskScore: this.calculateRiskScore(marketData),
      timestamp: new Date(),
      reason: this.generateReason(marketData, signalType, totalScore),
      confidence: this.calculateConfidence(totalScore),
      volume24h,
      indicators: {
        rsi: marketData.rsi,
        macd: marketData.macd,
        bollinger: marketData.bollinger,
      },
    };
  }

  /**
   * Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï†êÏàò Í≥ÑÏÇ∞ [11]
   */
  calculateTechnicalScores(marketData) {
    const { symbol, price, volume24h, rsi, macd, bollinger } = marketData;
    const rules =
      this.coinSpecificRules[symbol] || this.coinSpecificRules["ETH"];

    const scores = {
      rsi: this.calculateRsiScore(rsi, rules),
      movingAverage: this.calculateMovingAverageScore(marketData),
      bollinger: this.calculateBollingerScore(bollinger, price),
      macd: this.calculateMacdScore(macd),
      volume: this.calculateVolumeScore(volume24h, marketData.avgVolume),
      support: this.calculateSupportResistanceScore(marketData),
    };

    const totalScore = this.calculateTotalScore(scores);

    console.log(`üéØ ${symbol} Ïã†Ìò∏Î∂ÑÏÑù:`, {
      price: price,
      rsi: rsi?.toFixed(1),
      totalScore: totalScore.toFixed(2),
      threshold: this.defaultThresholds.minBuyScore,
      willBuy: totalScore >= this.defaultThresholds.minBuyScore,
      scores: Object.fromEntries(
        Object.entries(scores).map(([key, value]) => [key, value.toFixed(1)])
      ),
    });

    return scores;
  }

  /**
   * RSI Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateRsiScore(rsi, rules) {
    if (!rsi) return 0;

    if (rsi <= rules.rsiOversold) {
      return 10;
    } else if (rsi <= rules.rsiOversold + 10) {
      return 7;
    } else if (rsi >= rules.rsiOverbought) {
      return 0;
    } else if (rsi >= rules.rsiOverbought - 10) {
      return 3;
    } else {
      return 5;
    }
  }

  /**
   * Ïù¥ÎèôÌèâÍ∑† Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateMovingAverageScore(marketData) {
    const { price, ma20, ma60 } = marketData;
    if (!ma20 || !ma60) return 5;

    if (price > ma20 && ma20 > ma60) {
      return 10;
    } else if (price < ma20 && ma20 < ma60) {
      return 0;
    } else if (price > ma20 && price < ma60) {
      return 6;
    } else {
      return 4;
    }
  }

  /**
   * Î≥ºÎßÅÍ±∞Î∞¥Îìú Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateBollingerScore(bollinger, price) {
    if (!bollinger || !price) return 5;

    const { upper, middle, lower } = bollinger;

    if (price <= lower * 1.02) {
      return 10;
    } else if (price <= lower * 1.05) {
      return 8;
    } else if (price >= upper * 0.98) {
      return 0;
    } else {
      return 5;
    }
  }

  /**
   * MACD Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateMacdScore(macd) {
    if (!macd) return 5;

    const { line, signal, histogram } = macd;

    if (line > signal && histogram > 0) {
      return 10;
    } else if (line < signal && histogram < 0) {
      return 0;
    } else if (line > signal) {
      return 7;
    } else {
      return 3;
    }
  }

  /**
   * Í±∞ÎûòÎüâ Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateVolumeScore(volume24h, avgVolume) {
    if (!volume24h || !avgVolume) return 5;

    const volumeRatio = volume24h / avgVolume;

    if (volumeRatio >= 2.0) {
      return 10;
    } else if (volumeRatio >= 1.5) {
      return 8;
    } else if (volumeRatio >= 0.8) {
      return 5;
    } else {
      return 2;
    }
  }

  /**
   * ÏßÄÏßÄÏ†ÄÌï≠ Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateSupportResistanceScore(marketData) {
    const { price, support, resistance } = marketData;
    if (!support || !resistance) return 5;

    const supportDistance = (price - support) / support;
    const resistanceDistance = (resistance - price) / price;

    if (supportDistance <= 0.03 && supportDistance >= 0) {
      return 10;
    } else if (resistanceDistance <= 0.03) {
      return 2;
    } else {
      return 5;
    }
  }

  /**
   * Ï¥ùÏ†ê Í≥ÑÏÇ∞
   */
  calculateTotalScore(technicalScores) {
    let totalScore = 0;
    for (const [indicator, score] of Object.entries(technicalScores)) {
      const weight = this.weights.technical[indicator] || 0;
      totalScore += score * weight;
    }

    return Math.min(Math.max(totalScore, 0), this.defaultThresholds.maxScore);
  }

  /**
   * Ïã†Ìò∏ Ïú†Ìòï Í≤∞Ï†ï (Í∏∞Ï°¥ ÏΩîÎìú)
   */
  determineSignalType(marketData, totalScore) {
    const { rsi } = marketData;

    console.log(
      `üîç ${marketData.symbol} Ïã†Ìò∏ÌåêÎã®: Ï†êÏàò=${totalScore.toFixed(2)}, RSI=${rsi?.toFixed(1)}`
    );

    if (totalScore >= 5.0) {
      if (rsi && rsi < 80) {
        console.log(`‚úÖ ${marketData.symbol} Îß§ÏàòÏã†Ìò∏ Î∞úÏÉù!`);
        return "BUY";
      }
    }

    if (totalScore <= 3 || (rsi && rsi > 85)) {
      return "SELL";
    }

    return null;
  }

  /**
   * ÏúÑÌóò Ï†êÏàò Í≥ÑÏÇ∞
   */
  calculateRiskScore(marketData) {
    const { rsi, volume24h, avgVolume } = marketData;
    let riskScore = 5;

    if (rsi > 80 || rsi < 20) riskScore += 2;
    if (volume24h && avgVolume && volume24h > avgVolume * 3) {
      riskScore += 1;
    }

    return Math.min(Math.max(riskScore, 1), 10);
  }

  /**
   * Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
   */
  calculateConfidence(totalScore) {
    if (totalScore >= this.defaultThresholds.strongBuyScore) return "HIGH";
    if (totalScore >= this.defaultThresholds.minBuyScore) return "MEDIUM";
    if (totalScore >= this.defaultThresholds.minSellScore) return "LOW";
    return "VERY_LOW";
  }

  /**
   * Ïã†Ìò∏ ÏÇ¨Ïú† ÏÉùÏÑ± (Í∏∞Ï°¥ ÏΩîÎìú)
   */
  generateReason(marketData, signalType, totalScore) {
    const { symbol, rsi, volume24h, avgVolume } = marketData;
    const volumeRatio =
      volume24h && avgVolume ? (volume24h / avgVolume).toFixed(1) : "?";

    if (signalType === "BUY") {
      if (totalScore >= this.defaultThresholds.strongBuyScore) {
        return `${symbol} Í∞ïÎ†•Îß§Ïàò: Ï¢ÖÌï©Ï†êÏàò ${totalScore.toFixed(1)}Ï†ê, RSI ${rsi?.toFixed(1)}, Í±∞ÎûòÎüâ ${volumeRatio}Î∞∞`;
      } else {
        return `${symbol} Îß§Ïàò: Ï¢ÖÌï©Ï†êÏàò ${totalScore.toFixed(1)}Ï†ê, RSI ${rsi?.toFixed(1)}`;
      }
    } else if (signalType === "SELL") {
      return `${symbol} Îß§ÎèÑ: Í∏∞Ïà†Ï†Å Í≥ºÏó¥, RSI ${rsi?.toFixed(1)}`;
    }

    return `${symbol} Î∂ÑÏÑùÏôÑÎ£å`;
  }
}

// Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
export const signalGenerator = new SignalGenerator();

// Í∏∞Î≥∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
export default signalGenerator;

// Ìé∏Ïùò Ìï®ÏàòÎì§
export const generateSignals =
  signalGenerator.generateSignals.bind(signalGenerator);
export const analyzeSymbol =
  signalGenerator.analyzeSymbol.bind(signalGenerator);

// ‚úÖ ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ÏÑ§Ï†ï Í∏∞Î∞ò Ìï®ÏàòÎì§
export const generateSignalsWithSettings =
  signalGenerator.generateSignalsWithSettings.bind(signalGenerator);
export const analyzeSymbolWithSettings =
  signalGenerator.analyzeSymbolWithSettings.bind(signalGenerator);
